{"ast":null,"code":"// Utility to generate N random, non-overlapping times within a day and window\n// minGapMinutes: minimum gap between times (e.g., 10)\n// windowStart, windowEnd: 'HH:mm' (e.g., '08:00', '22:00')\n\n// Helper to get a Date object in UTC for a given IST date and time\nfunction getISTDate(dateStr, timeStr) {\n  // dateStr: 'YYYY-MM-DD', timeStr: 'HH:mm'\n  const [year, month, day] = dateStr.split('-').map(Number);\n  const [hour, minute] = timeStr.split(':').map(Number);\n  // IST is UTC+5:30, so subtract 5.5 hours to get UTC time\n  const utcHour = hour - 5;\n  const utcMinute = minute - 30;\n  // Handle minute underflow\n  let finalHour = utcHour;\n  let finalMinute = utcMinute;\n  if (utcMinute < 0) {\n    finalHour -= 1;\n    finalMinute += 60;\n  }\n  return new Date(Date.UTC(year, month - 1, day, finalHour, finalMinute, 0, 0));\n}\nexport function generateRandomSchedule({\n  date,\n  // 'YYYY-MM-DD'\n  count,\n  // number of reels\n  minGapMinutes = 10,\n  windowStart = '12:00',\n  // IST\n  windowEnd = '20:00' // IST\n}) {\n  // Always use the selected date for both start and end\n  const start = getISTDate(date, windowStart);\n  const end = getISTDate(date, windowEnd);\n  const minGapMs = minGapMinutes * 60 * 1000;\n  const totalWindowMs = end - start;\n  if (count * minGapMs > totalWindowMs) throw new Error('Not enough time for all reels with the given gap.');\n  // Generate slots\n  let slots = [];\n  for (let i = 0; i < count; i++) {\n    slots.push(i * minGapMs);\n  }\n  // Shuffle slots randomly within window\n  const randomOffsets = slots.map((gap, i) => gap + Math.floor(Math.random() * (totalWindowMs - count * minGapMs) / count));\n  // Sort and map to timestamps\n  randomOffsets.sort((a, b) => a - b);\n  return randomOffsets.map(offset => new Date(start.getTime() + offset));\n}","map":{"version":3,"names":["getISTDate","dateStr","timeStr","year","month","day","split","map","Number","hour","minute","utcHour","utcMinute","finalHour","finalMinute","Date","UTC","generateRandomSchedule","date","count","minGapMinutes","windowStart","windowEnd","start","end","minGapMs","totalWindowMs","Error","slots","i","push","randomOffsets","gap","Math","floor","random","sort","a","b","offset","getTime"],"sources":["C:/Users/sangeeth/Desktop/ree/frontend/src/scheduleUtils.js"],"sourcesContent":["// Utility to generate N random, non-overlapping times within a day and window\r\n// minGapMinutes: minimum gap between times (e.g., 10)\r\n// windowStart, windowEnd: 'HH:mm' (e.g., '08:00', '22:00')\r\n\r\n// Helper to get a Date object in UTC for a given IST date and time\r\nfunction getISTDate(dateStr, timeStr) {\r\n  // dateStr: 'YYYY-MM-DD', timeStr: 'HH:mm'\r\n  const [year, month, day] = dateStr.split('-').map(Number);\r\n  const [hour, minute] = timeStr.split(':').map(Number);\r\n  // IST is UTC+5:30, so subtract 5.5 hours to get UTC time\r\n  const utcHour = hour - 5;\r\n  const utcMinute = minute - 30;\r\n  // Handle minute underflow\r\n  let finalHour = utcHour;\r\n  let finalMinute = utcMinute;\r\n  if (utcMinute < 0) {\r\n    finalHour -= 1;\r\n    finalMinute += 60;\r\n  }\r\n  return new Date(Date.UTC(year, month - 1, day, finalHour, finalMinute, 0, 0));\r\n}\r\n\r\nexport function generateRandomSchedule({\r\n  date, // 'YYYY-MM-DD'\r\n  count, // number of reels\r\n  minGapMinutes = 10,\r\n  windowStart = '12:00', // IST\r\n  windowEnd = '20:00',   // IST\r\n}) {\r\n  // Always use the selected date for both start and end\r\n  const start = getISTDate(date, windowStart);\r\n  const end = getISTDate(date, windowEnd);\r\n  const minGapMs = minGapMinutes * 60 * 1000;\r\n  const totalWindowMs = end - start;\r\n  if (count * minGapMs > totalWindowMs) throw new Error('Not enough time for all reels with the given gap.');\r\n  // Generate slots\r\n  let slots = [];\r\n  for (let i = 0; i < count; i++) {\r\n    slots.push(i * minGapMs);\r\n  }\r\n  // Shuffle slots randomly within window\r\n  const randomOffsets = slots.map((gap, i) => gap + Math.floor(Math.random() * (totalWindowMs - count * minGapMs) / count));\r\n  // Sort and map to timestamps\r\n  randomOffsets.sort((a, b) => a - b);\r\n  return randomOffsets.map(offset => new Date(start.getTime() + offset));\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA,SAASA,UAAUA,CAACC,OAAO,EAAEC,OAAO,EAAE;EACpC;EACA,MAAM,CAACC,IAAI,EAAEC,KAAK,EAAEC,GAAG,CAAC,GAAGJ,OAAO,CAACK,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC;EACzD,MAAM,CAACC,IAAI,EAAEC,MAAM,CAAC,GAAGR,OAAO,CAACI,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC;EACrD;EACA,MAAMG,OAAO,GAAGF,IAAI,GAAG,CAAC;EACxB,MAAMG,SAAS,GAAGF,MAAM,GAAG,EAAE;EAC7B;EACA,IAAIG,SAAS,GAAGF,OAAO;EACvB,IAAIG,WAAW,GAAGF,SAAS;EAC3B,IAAIA,SAAS,GAAG,CAAC,EAAE;IACjBC,SAAS,IAAI,CAAC;IACdC,WAAW,IAAI,EAAE;EACnB;EACA,OAAO,IAAIC,IAAI,CAACA,IAAI,CAACC,GAAG,CAACb,IAAI,EAAEC,KAAK,GAAG,CAAC,EAAEC,GAAG,EAAEQ,SAAS,EAAEC,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAC/E;AAEA,OAAO,SAASG,sBAAsBA,CAAC;EACrCC,IAAI;EAAE;EACNC,KAAK;EAAE;EACPC,aAAa,GAAG,EAAE;EAClBC,WAAW,GAAG,OAAO;EAAE;EACvBC,SAAS,GAAG,OAAO,CAAI;AACzB,CAAC,EAAE;EACD;EACA,MAAMC,KAAK,GAAGvB,UAAU,CAACkB,IAAI,EAAEG,WAAW,CAAC;EAC3C,MAAMG,GAAG,GAAGxB,UAAU,CAACkB,IAAI,EAAEI,SAAS,CAAC;EACvC,MAAMG,QAAQ,GAAGL,aAAa,GAAG,EAAE,GAAG,IAAI;EAC1C,MAAMM,aAAa,GAAGF,GAAG,GAAGD,KAAK;EACjC,IAAIJ,KAAK,GAAGM,QAAQ,GAAGC,aAAa,EAAE,MAAM,IAAIC,KAAK,CAAC,mDAAmD,CAAC;EAC1G;EACA,IAAIC,KAAK,GAAG,EAAE;EACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,KAAK,EAAEU,CAAC,EAAE,EAAE;IAC9BD,KAAK,CAACE,IAAI,CAACD,CAAC,GAAGJ,QAAQ,CAAC;EAC1B;EACA;EACA,MAAMM,aAAa,GAAGH,KAAK,CAACrB,GAAG,CAAC,CAACyB,GAAG,EAAEH,CAAC,KAAKG,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIT,aAAa,GAAGP,KAAK,GAAGM,QAAQ,CAAC,GAAGN,KAAK,CAAC,CAAC;EACzH;EACAY,aAAa,CAACK,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;EACnC,OAAOP,aAAa,CAACxB,GAAG,CAACgC,MAAM,IAAI,IAAIxB,IAAI,CAACQ,KAAK,CAACiB,OAAO,CAAC,CAAC,GAAGD,MAAM,CAAC,CAAC;AACxE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}