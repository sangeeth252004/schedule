{"ast":null,"code":"// Utility to generate N random, non-overlapping times within a day and window\n// minGapMinutes: minimum gap between times (e.g., 10)\n// windowStart, windowEnd: 'HH:mm' (e.g., '08:00', '22:00')\nexport function generateRandomSchedule({\n  date,\n  // 'YYYY-MM-DD'\n  count,\n  // number of reels\n  minGapMinutes = 10,\n  windowStart = '08:00',\n  windowEnd = '22:00'\n}) {\n  const start = new Date(`${date}T${windowStart}:00`);\n  const end = new Date(`${date}T${windowEnd}:00`);\n  const minGapMs = minGapMinutes * 60 * 1000;\n  const totalWindowMs = end - start;\n  if (count * minGapMs > totalWindowMs) throw new Error('Not enough time for all reels with the given gap.');\n  // Generate slots\n  let slots = [];\n  for (let i = 0; i < count; i++) {\n    slots.push(i * minGapMs);\n  }\n  // Shuffle slots randomly within window\n  const randomOffsets = slots.map((gap, i) => gap + Math.floor(Math.random() * (totalWindowMs - count * minGapMs) / count));\n  // Sort and map to timestamps\n  randomOffsets.sort((a, b) => a - b);\n  return randomOffsets.map(offset => new Date(start.getTime() + offset));\n}","map":{"version":3,"names":["generateRandomSchedule","date","count","minGapMinutes","windowStart","windowEnd","start","Date","end","minGapMs","totalWindowMs","Error","slots","i","push","randomOffsets","map","gap","Math","floor","random","sort","a","b","offset","getTime"],"sources":["C:/Users/sangeeth/Desktop/ree/frontend/src/scheduleUtils.js"],"sourcesContent":["// Utility to generate N random, non-overlapping times within a day and window\r\n// minGapMinutes: minimum gap between times (e.g., 10)\r\n// windowStart, windowEnd: 'HH:mm' (e.g., '08:00', '22:00')\r\nexport function generateRandomSchedule({\r\n  date, // 'YYYY-MM-DD'\r\n  count, // number of reels\r\n  minGapMinutes = 10,\r\n  windowStart = '08:00',\r\n  windowEnd = '22:00',\r\n}) {\r\n  const start = new Date(`${date}T${windowStart}:00`);\r\n  const end = new Date(`${date}T${windowEnd}:00`);\r\n  const minGapMs = minGapMinutes * 60 * 1000;\r\n  const totalWindowMs = end - start;\r\n  if (count * minGapMs > totalWindowMs) throw new Error('Not enough time for all reels with the given gap.');\r\n  // Generate slots\r\n  let slots = [];\r\n  for (let i = 0; i < count; i++) {\r\n    slots.push(i * minGapMs);\r\n  }\r\n  // Shuffle slots randomly within window\r\n  const randomOffsets = slots.map((gap, i) => gap + Math.floor(Math.random() * (totalWindowMs - count * minGapMs) / count));\r\n  // Sort and map to timestamps\r\n  randomOffsets.sort((a, b) => a - b);\r\n  return randomOffsets.map(offset => new Date(start.getTime() + offset));\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAO,SAASA,sBAAsBA,CAAC;EACrCC,IAAI;EAAE;EACNC,KAAK;EAAE;EACPC,aAAa,GAAG,EAAE;EAClBC,WAAW,GAAG,OAAO;EACrBC,SAAS,GAAG;AACd,CAAC,EAAE;EACD,MAAMC,KAAK,GAAG,IAAIC,IAAI,CAAC,GAAGN,IAAI,IAAIG,WAAW,KAAK,CAAC;EACnD,MAAMI,GAAG,GAAG,IAAID,IAAI,CAAC,GAAGN,IAAI,IAAII,SAAS,KAAK,CAAC;EAC/C,MAAMI,QAAQ,GAAGN,aAAa,GAAG,EAAE,GAAG,IAAI;EAC1C,MAAMO,aAAa,GAAGF,GAAG,GAAGF,KAAK;EACjC,IAAIJ,KAAK,GAAGO,QAAQ,GAAGC,aAAa,EAAE,MAAM,IAAIC,KAAK,CAAC,mDAAmD,CAAC;EAC1G;EACA,IAAIC,KAAK,GAAG,EAAE;EACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,KAAK,EAAEW,CAAC,EAAE,EAAE;IAC9BD,KAAK,CAACE,IAAI,CAACD,CAAC,GAAGJ,QAAQ,CAAC;EAC1B;EACA;EACA,MAAMM,aAAa,GAAGH,KAAK,CAACI,GAAG,CAAC,CAACC,GAAG,EAAEJ,CAAC,KAAKI,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIV,aAAa,GAAGR,KAAK,GAAGO,QAAQ,CAAC,GAAGP,KAAK,CAAC,CAAC;EACzH;EACAa,aAAa,CAACM,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;EACnC,OAAOR,aAAa,CAACC,GAAG,CAACQ,MAAM,IAAI,IAAIjB,IAAI,CAACD,KAAK,CAACmB,OAAO,CAAC,CAAC,GAAGD,MAAM,CAAC,CAAC;AACxE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}