{"ast":null,"code":"// Utility to generate N random, non-overlapping times within a day and window\n// minGapMinutes: minimum gap between times (e.g., 10)\n// windowStart, windowEnd: 'HH:mm' (e.g., '08:00', '22:00')\n\n// Helper to get a Date object in UTC for a given date and time (no timezone math)\nfunction getUTCDate(dateStr, timeStr) {\n  // dateStr: 'YYYY-MM-DD', timeStr: 'HH:mm' (UTC)\n  const [year, month, day] = dateStr.split('-').map(Number);\n  const [hour, minute] = timeStr.split(':').map(Number);\n  return new Date(Date.UTC(year, month - 1, day, hour, minute, 0, 0));\n}\nexport function generateRandomSchedule({\n  date,\n  // 'YYYY-MM-DD'\n  count,\n  // number of reels\n  minGapMinutes = 10,\n  windowStart = '12:00',\n  // UTC\n  windowEnd = '20:00' // UTC\n}) {\n  // Use UTC times for both start and end\n  const start = getUTCDate(date, windowStart);\n  const end = getUTCDate(date, windowEnd);\n  const minGapMs = minGapMinutes * 60 * 1000;\n  const totalWindowMs = end - start;\n  if (count * minGapMs > totalWindowMs) throw new Error('Not enough time for all reels with the given gap.');\n  let slots = [];\n  for (let i = 0; i < count; i++) {\n    slots.push(i * minGapMs);\n  }\n  const randomOffsets = slots.map((gap, i) => gap + Math.floor(Math.random() * (totalWindowMs - count * minGapMs) / count));\n  randomOffsets.sort((a, b) => a - b);\n  return randomOffsets.map(offset => new Date(start.getTime() + offset));\n}","map":{"version":3,"names":["getUTCDate","dateStr","timeStr","year","month","day","split","map","Number","hour","minute","Date","UTC","generateRandomSchedule","date","count","minGapMinutes","windowStart","windowEnd","start","end","minGapMs","totalWindowMs","Error","slots","i","push","randomOffsets","gap","Math","floor","random","sort","a","b","offset","getTime"],"sources":["C:/Users/sangeeth/Desktop/ree/frontend/src/scheduleUtils.js"],"sourcesContent":["// Utility to generate N random, non-overlapping times within a day and window\r\n// minGapMinutes: minimum gap between times (e.g., 10)\r\n// windowStart, windowEnd: 'HH:mm' (e.g., '08:00', '22:00')\r\n\r\n\r\n// Helper to get a Date object in UTC for a given date and time (no timezone math)\r\nfunction getUTCDate(dateStr, timeStr) {\r\n  // dateStr: 'YYYY-MM-DD', timeStr: 'HH:mm' (UTC)\r\n  const [year, month, day] = dateStr.split('-').map(Number);\r\n  const [hour, minute] = timeStr.split(':').map(Number);\r\n  return new Date(Date.UTC(year, month - 1, day, hour, minute, 0, 0));\r\n}\r\n\r\nexport function generateRandomSchedule({\r\n  date, // 'YYYY-MM-DD'\r\n  count, // number of reels\r\n  minGapMinutes = 10,\r\n  windowStart = '12:00', // UTC\r\n  windowEnd = '20:00',   // UTC\r\n}) {\r\n  // Use UTC times for both start and end\r\n  const start = getUTCDate(date, windowStart);\r\n  const end = getUTCDate(date, windowEnd);\r\n  const minGapMs = minGapMinutes * 60 * 1000;\r\n  const totalWindowMs = end - start;\r\n  if (count * minGapMs > totalWindowMs) throw new Error('Not enough time for all reels with the given gap.');\r\n  let slots = [];\r\n  for (let i = 0; i < count; i++) {\r\n    slots.push(i * minGapMs);\r\n  }\r\n  const randomOffsets = slots.map((gap, i) => gap + Math.floor(Math.random() * (totalWindowMs - count * minGapMs) / count));\r\n  randomOffsets.sort((a, b) => a - b);\r\n  return randomOffsets.map(offset => new Date(start.getTime() + offset));\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;;AAGA;AACA,SAASA,UAAUA,CAACC,OAAO,EAAEC,OAAO,EAAE;EACpC;EACA,MAAM,CAACC,IAAI,EAAEC,KAAK,EAAEC,GAAG,CAAC,GAAGJ,OAAO,CAACK,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC;EACzD,MAAM,CAACC,IAAI,EAAEC,MAAM,CAAC,GAAGR,OAAO,CAACI,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,MAAM,CAAC;EACrD,OAAO,IAAIG,IAAI,CAACA,IAAI,CAACC,GAAG,CAACT,IAAI,EAAEC,KAAK,GAAG,CAAC,EAAEC,GAAG,EAAEI,IAAI,EAAEC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACrE;AAEA,OAAO,SAASG,sBAAsBA,CAAC;EACrCC,IAAI;EAAE;EACNC,KAAK;EAAE;EACPC,aAAa,GAAG,EAAE;EAClBC,WAAW,GAAG,OAAO;EAAE;EACvBC,SAAS,GAAG,OAAO,CAAI;AACzB,CAAC,EAAE;EACD;EACA,MAAMC,KAAK,GAAGnB,UAAU,CAACc,IAAI,EAAEG,WAAW,CAAC;EAC3C,MAAMG,GAAG,GAAGpB,UAAU,CAACc,IAAI,EAAEI,SAAS,CAAC;EACvC,MAAMG,QAAQ,GAAGL,aAAa,GAAG,EAAE,GAAG,IAAI;EAC1C,MAAMM,aAAa,GAAGF,GAAG,GAAGD,KAAK;EACjC,IAAIJ,KAAK,GAAGM,QAAQ,GAAGC,aAAa,EAAE,MAAM,IAAIC,KAAK,CAAC,mDAAmD,CAAC;EAC1G,IAAIC,KAAK,GAAG,EAAE;EACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,KAAK,EAAEU,CAAC,EAAE,EAAE;IAC9BD,KAAK,CAACE,IAAI,CAACD,CAAC,GAAGJ,QAAQ,CAAC;EAC1B;EACA,MAAMM,aAAa,GAAGH,KAAK,CAACjB,GAAG,CAAC,CAACqB,GAAG,EAAEH,CAAC,KAAKG,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIT,aAAa,GAAGP,KAAK,GAAGM,QAAQ,CAAC,GAAGN,KAAK,CAAC,CAAC;EACzHY,aAAa,CAACK,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;EACnC,OAAOP,aAAa,CAACpB,GAAG,CAAC4B,MAAM,IAAI,IAAIxB,IAAI,CAACQ,KAAK,CAACiB,OAAO,CAAC,CAAC,GAAGD,MAAM,CAAC,CAAC;AACxE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}